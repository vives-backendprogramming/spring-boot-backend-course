# Lesson 7: DTOs & Mappers

**Data Transfer Objects and Entity-DTO Mapping**

---

## üìã Learning Objectives

By the end of this lesson, you will be able to:
- Understand why DTOs are essential and why entities should **never** be exposed directly
- Differentiate between Request DTOs and Response DTOs
- Implement DTOs for proper API design
- Use MapStruct for automatic mapping between entities and DTOs
- Structure your Spring Boot project with proper layering
- Apply DTO pattern to the PizzaStore application

---

## üìö Table of Contents

1. [The Problem: Why Not Expose Entities?](#the-problem-why-not-expose-entities)
2. [What Are DTOs?](#what-are-dtos)
3. [Request vs Response DTOs](#request-vs-response-dtos)
4. [Mapping Strategies](#mapping-strategies)
5. [MapStruct: The Best Choice](#mapstruct-the-best-choice)
6. [Project Structure with DTOs](#project-structure-with-dtos)
7. [PizzaStore: Adding DTOs](#pizzastore-adding-dtos)
8. [Testing with DTOs](#testing-with-dtos)
9. [Summary](#summary)

---

## üö´ The Problem: Why Not Expose Entities?

### What's Wrong with This Code?

```java
@RestController
@RequestMapping("/api/pizzas")
public class PizzaController {
    
    @Autowired
    private PizzaRepository pizzaRepository;
    
    // ‚ùå BAD: Returning entity directly
    @GetMapping("/{id}")
    public Pizza getPizza(@PathVariable Long id) {
        return pizzaRepository.findById(id).orElse(null);
    }
    
    // ‚ùå BAD: Accepting entity directly
    @PostMapping
    public Pizza createPizza(@RequestBody Pizza pizza) {
        return pizzaRepository.save(pizza);
    }
}
```

### Problems with Exposing Entities

#### 1. **Security & Privacy Risks** üîí

Entities often contain sensitive data that should never be exposed:

```java
@Entity
@Table(name = "customers")
public class Customer {
    private Long id;
    private String name;
    private String email;
    private String password;           // ‚ùå Exposed!
    private String creditCardNumber;   // ‚ùå Exposed!
    private LocalDateTime lastLogin;   // ‚ùå Internal data exposed!
    private boolean accountLocked;     // ‚ùå Exposed!
    private BigDecimal totalSpent;     // ‚ùå Internal business data!
}
```

When you return this entity, **all fields** are serialized to JSON, including sensitive ones!

#### 2. **Tight Coupling** üîó

Your API structure becomes tightly coupled to your database structure:

```java
@Entity
@Table(name = "orders")
public class PizzaOrder {
    private Long id;
    private String orderNumber;
    private BigDecimal totalAmount;
    
    // If you change the entity, the API changes!
    @OneToMany
    private List<OrderLine> orderLines; // Complex nested structure exposed
    
    @ManyToOne
    private Customer customer;          // Entire customer object (with password!) exposed
    
    @Enumerated(EnumType.STRING)
    private OrderStatus status;         // Internal workflow status exposed
}
```

**Problem**: Database changes = API breaking changes = angry mobile app developers! üò†

#### 3. **Over-fetching & Under-fetching** üì¶

Entities don't match what the client actually needs:

```java
// Client wants: id, name, price
// Client gets: id, name, price, description, category, ingredients, 
//              allergens, nutritionalInfo, internalNotes, supplierId, etc.
```

**Result**: 
- Wasted bandwidth
- Slower API responses
- Client has to filter unnecessary data

#### 4. **Lazy Loading Issues** üí§

JPA entities with relationships can cause `LazyInitializationException`:

```java
@Entity
public class Pizza {
    @ManyToOne(fetch = FetchType.LAZY)
    private Category category;  // Not loaded!
}

// In controller:
Pizza pizza = pizzaRepository.findById(id).orElseThrow();
return pizza; // Jackson tries to serialize category ‚Üí Exception!
```

#### 5. **No Validation Control** ‚úÖ

Can't have different validation rules for create vs update:

```java
@Entity
public class Pizza {
    @NotNull // Must be present even when creating? No!
    private Long id;
    
    @NotBlank
    private String name;
}

// Creating: ID should be null (generated by database)
// Updating: ID should be present
// One validation doesn't fit both!
```

#### 6. **Can't Control JSON Structure** üìÑ

Limited control over API response format:

```java
// Want this:
{
  "pizzaId": 1,
  "pizzaName": "Margherita"
}

// But entity gives you:
{
  "id": 1,
  "name": "Margherita"
}
```

---

## üéØ What Are DTOs?

**DTO (Data Transfer Object)** is a simple object that carries data between processes.

### Key Characteristics

- **Plain objects** (POJOs) - no JPA annotations
- **Purpose-built** for specific API operations
- **No business logic** - pure data carriers
- **Immutable (preferably)** - use records or final fields

### When to Use DTOs

‚úÖ **Always** when building REST APIs  
‚úÖ **Every** controller endpoint (input and output)  
‚úÖ **Between** different layers (API ‚Üî Service ‚Üî Repository)

---

## üì•üì§ Request vs Response DTOs

### Request DTOs (Input)

Used for **creating** or **updating** resources.

```java
public record CreatePizzaRequest(
    @NotBlank(message = "Name is required")
    String name,
    
    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.01", message = "Price must be positive")
    BigDecimal price,
    
    String description
) {}
```

**Characteristics**:
- No `id` field (generated by database)
- Validation annotations
- Only fields the client can set

### Response DTOs (Output)

Used for **returning** resources to clients.

```java
public record PizzaResponse(
    Long id,
    String name,
    BigDecimal price,
    String description,
    LocalDateTime createdAt
) {}
```

**Characteristics**:
- Includes `id` field
- May include computed/derived fields
- Read-only representation

### Update DTOs

Sometimes you need a separate DTO for updates:

```java
public record UpdatePizzaRequest(
    @NotNull(message = "ID is required")
    Long id,
    
    @NotBlank(message = "Name is required")
    String name,
    
    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.01", message = "Price must be positive")
    BigDecimal price,
    
    String description
) {}
```

---

## üîÑ Mapping Strategies

How do we convert between entities and DTOs?

### Option 1: Manual Mapping ‚ùå

```java
public PizzaResponse toPizzaResponse(Pizza pizza) {
    return new PizzaResponse(
        pizza.getId(),
        pizza.getName(),
        pizza.getPrice(),
        pizza.getDescription(),
        pizza.getCreatedAt()
    );
}
```

**Problems**:
- Tedious and repetitive
- Error-prone (easy to miss fields)
- No compile-time safety
- Hard to maintain

### Option 2: ModelMapper ‚ö†Ô∏è

```java
ModelMapper mapper = new ModelMapper();
PizzaResponse response = mapper.map(pizza, PizzaResponse.class);
```

**Problems**:
- Runtime mapping (reflection)
- Slower performance
- Hard to debug when it goes wrong
- Magic behavior (hard to predict)

### Option 3: MapStruct ‚úÖ (Recommended)

```java
@Mapper(componentModel = "spring")
public interface PizzaMapper {
    PizzaResponse toPizzaResponse(Pizza pizza);
    Pizza toEntity(CreatePizzaRequest request);
}
```

**Advantages**:
- Compile-time code generation
- Type-safe
- Fast (no reflection)
- Easy to debug (generated code is readable)
- Highly customizable

---

## üèÜ MapStruct: The Best Choice

### Why MapStruct?

1. **Compile-time generation** - errors caught early
2. **Performance** - generated code is as fast as hand-written
3. **Type safety** - compiler checks everything
4. **Readable** - generated code is easy to understand
5. **Customizable** - easy to handle special cases
6. **Spring integration** - works seamlessly with dependency injection

### Adding MapStruct to Your Project

Add to `pom.xml`:

```xml
<properties>
    <org.mapstruct.version>1.5.5.Final</org.mapstruct.version>
    <lombok.version>1.18.30</lombok.version>
</properties>

<dependencies>
    <!-- MapStruct -->
    <dependency>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
        <version>${org.mapstruct.version}</version>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <configuration>
                <source>21</source>
                <target>21</target>
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.mapstruct</groupId>
                        <artifactId>mapstruct-processor</artifactId>
                        <version>${org.mapstruct.version}</version>
                    </path>
                    <!-- If using Lombok -->
                    <path>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                        <version>${lombok.version}</version>
                    </path>
                    <path>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok-mapstruct-binding</artifactId>
                        <version>0.2.0</version>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>
```

### Basic MapStruct Mapper

```java
package be.vives.pizzastore.mapper;

import be.vives.pizzastore.domain.Pizza;
import be.vives.pizzastore.dto.CreatePizzaRequest;
import be.vives.pizzastore.dto.PizzaResponse;
import be.vives.pizzastore.dto.UpdatePizzaRequest;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PizzaMapper {
    
    // Entity to Response DTO
    PizzaResponse toResponse(Pizza pizza);
    
    // List of entities to list of Response DTOs
    List<PizzaResponse> toResponseList(List<Pizza> pizzas);
    
    // Create Request DTO to Entity
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    Pizza toEntity(CreatePizzaRequest request);
    
    // Update existing entity from Update Request DTO
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateEntityFromRequest(UpdatePizzaRequest request, @MappingTarget Pizza pizza);
}
```

### Custom Mapping

Sometimes field names don't match:

```java
@Mapper(componentModel = "spring")
public interface PizzaMapper {
    
    @Mapping(source = "name", target = "pizzaName")
    @Mapping(source = "price", target = "pizzaPrice")
    PizzaResponse toResponse(Pizza pizza);
}
```

### Handling Nested Objects

```java
@Mapper(componentModel = "spring", uses = {CategoryMapper.class})
public interface PizzaMapper {
    
    // MapStruct will automatically use CategoryMapper for the category field
    PizzaResponse toResponse(Pizza pizza);
}

@Mapper(componentModel = "spring")
public interface CategoryMapper {
    CategoryResponse toResponse(Category category);
}
```

### How MapStruct Works

After you define the mapper interface, MapStruct generates the implementation:

```java
// You write this:
@Mapper(componentModel = "spring")
public interface PizzaMapper {
    PizzaResponse toResponse(Pizza pizza);
}

// MapStruct generates this:
@Component
public class PizzaMapperImpl implements PizzaMapper {
    
    @Override
    public PizzaResponse toResponse(Pizza pizza) {
        if (pizza == null) {
            return null;
        }
        
        return new PizzaResponse(
            pizza.getId(),
            pizza.getName(),
            pizza.getPrice(),
            pizza.getDescription(),
            pizza.getCreatedAt()
        );
    }
}
```

Generated code is in `target/generated-sources/annotations/`.

---

## üìÅ Project Structure with DTOs

### Recommended Package Structure

```
src/main/java/be/vives/pizzastore/
‚îú‚îÄ‚îÄ domain/              # Entities (JPA)
‚îÇ   ‚îú‚îÄ‚îÄ Pizza.java
‚îÇ   ‚îú‚îÄ‚îÄ Customer.java
‚îÇ   ‚îî‚îÄ‚îÄ Order.java
‚îú‚îÄ‚îÄ dto/                 # Data Transfer Objects
‚îÇ   ‚îú‚îÄ‚îÄ request/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreatePizzaRequest.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UpdatePizzaRequest.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateOrderRequest.java
‚îÇ   ‚îî‚îÄ‚îÄ response/
‚îÇ       ‚îú‚îÄ‚îÄ PizzaResponse.java
‚îÇ       ‚îú‚îÄ‚îÄ CustomerResponse.java
‚îÇ       ‚îî‚îÄ‚îÄ OrderResponse.java
‚îú‚îÄ‚îÄ mapper/              # MapStruct Mappers
‚îÇ   ‚îú‚îÄ‚îÄ PizzaMapper.java
‚îÇ   ‚îú‚îÄ‚îÄ CustomerMapper.java
‚îÇ   ‚îî‚îÄ‚îÄ OrderMapper.java
‚îú‚îÄ‚îÄ repository/          # Spring Data JPA Repositories
‚îÇ   ‚îú‚îÄ‚îÄ PizzaRepository.java
‚îÇ   ‚îú‚îÄ‚îÄ CustomerRepository.java
‚îÇ   ‚îî‚îÄ‚îÄ OrderRepository.java
‚îú‚îÄ‚îÄ service/             # Business Logic
‚îÇ   ‚îú‚îÄ‚îÄ PizzaService.java
‚îÇ   ‚îú‚îÄ‚îÄ CustomerService.java
‚îÇ   ‚îî‚îÄ‚îÄ OrderService.java
‚îî‚îÄ‚îÄ controller/          # REST Controllers
    ‚îú‚îÄ‚îÄ PizzaController.java
    ‚îú‚îÄ‚îÄ CustomerController.java
    ‚îî‚îÄ‚îÄ OrderController.java
```

### Data Flow

```
Client Request (JSON)
    ‚Üì
Controller (receives Request DTO)
    ‚Üì
Mapper (Request DTO ‚Üí Entity)
    ‚Üì
Service (business logic with Entity)
    ‚Üì
Repository (persist Entity)
    ‚Üì
Service (return Entity)
    ‚Üì
Mapper (Entity ‚Üí Response DTO)
    ‚Üì
Controller (return Response DTO)
    ‚Üì
Client Response (JSON)
```

---

## üçï PizzaStore: Adding DTOs

### Step 1: Create DTOs

#### CreatePizzaRequest.java

```java
package be.vives.pizzastore.dto.request;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;

public record CreatePizzaRequest(
    
    @NotBlank(message = "Name is required")
    String name,
    
    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.01", message = "Price must be positive")
    BigDecimal price,
    
    String description
) {}
```

#### UpdatePizzaRequest.java

```java
package be.vives.pizzastore.dto.request;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;

public record UpdatePizzaRequest(
    
    @NotBlank(message = "Name is required")
    String name,
    
    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.01", message = "Price must be positive")
    BigDecimal price,
    
    String description
) {}
```

#### PizzaResponse.java

```java
package be.vives.pizzastore.dto.response;

import java.math.BigDecimal;
import java.time.LocalDateTime;

public record PizzaResponse(
    Long id,
    String name,
    BigDecimal price,
    String description,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {}
```

### Step 2: Update Entity with Timestamps

```java
package be.vives.pizzastore.domain;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "pizzas")
public class Pizza {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    private BigDecimal price;
    
    @Column(length = 1000)
    private String description;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    // Constructors
    public Pizza() {}
    
    public Pizza(String name, BigDecimal price, String description) {
        this.name = name;
        this.price = price;
        this.description = description;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public BigDecimal getPrice() { return price; }
    public void setPrice(BigDecimal price) { this.price = price; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}
```

### Step 3: Create Mapper

```java
package be.vives.pizzastore.mapper;

import be.vives.pizzastore.domain.Pizza;
import be.vives.pizzastore.dto.request.CreatePizzaRequest;
import be.vives.pizzastore.dto.request.UpdatePizzaRequest;
import be.vives.pizzastore.dto.response.PizzaResponse;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(componentModel = "spring")
public interface PizzaMapper {
    
    PizzaResponse toResponse(Pizza pizza);
    
    List<PizzaResponse> toResponseList(List<Pizza> pizzas);
    
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    Pizza toEntity(CreatePizzaRequest request);
    
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateEntity(UpdatePizzaRequest request, @MappingTarget Pizza pizza);
}
```

### Step 4: Update Service

```java
package be.vives.pizzastore.service;

import be.vives.pizzastore.domain.Pizza;
import be.vives.pizzastore.dto.request.CreatePizzaRequest;
import be.vives.pizzastore.dto.request.UpdatePizzaRequest;
import be.vives.pizzastore.dto.response.PizzaResponse;
import be.vives.pizzastore.mapper.PizzaMapper;
import be.vives.pizzastore.repository.PizzaRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class PizzaService {
    
    private final PizzaRepository pizzaRepository;
    private final PizzaMapper pizzaMapper;
    
    public PizzaService(PizzaRepository pizzaRepository, PizzaMapper pizzaMapper) {
        this.pizzaRepository = pizzaRepository;
        this.pizzaMapper = pizzaMapper;
    }
    
    public List<PizzaResponse> findAll() {
        List<Pizza> pizzas = pizzaRepository.findAll();
        return pizzaMapper.toResponseList(pizzas);
    }
    
    public Optional<PizzaResponse> findById(Long id) {
        return pizzaRepository.findById(id)
                .map(pizzaMapper::toResponse);
    }
    
    public PizzaResponse create(CreatePizzaRequest request) {
        Pizza pizza = pizzaMapper.toEntity(request);
        Pizza savedPizza = pizzaRepository.save(pizza);
        return pizzaMapper.toResponse(savedPizza);
    }
    
    public Optional<PizzaResponse> update(Long id, UpdatePizzaRequest request) {
        return pizzaRepository.findById(id)
                .map(pizza -> {
                    pizzaMapper.updateEntity(request, pizza);
                    Pizza updatedPizza = pizzaRepository.save(pizza);
                    return pizzaMapper.toResponse(updatedPizza);
                });
    }
    
    public boolean delete(Long id) {
        if (pizzaRepository.existsById(id)) {
            pizzaRepository.deleteById(id);
            return true;
        }
        return false;
    }
}
```

### Step 5: Update Controller

```java
package be.vives.pizzastore.controller;

import be.vives.pizzastore.dto.request.CreatePizzaRequest;
import be.vives.pizzastore.dto.request.UpdatePizzaRequest;
import be.vives.pizzastore.dto.response.PizzaResponse;
import be.vives.pizzastore.service.PizzaService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/api/pizzas")
public class PizzaController {
    
    private final PizzaService pizzaService;
    
    public PizzaController(PizzaService pizzaService) {
        this.pizzaService = pizzaService;
    }
    
    @GetMapping
    public ResponseEntity<List<PizzaResponse>> getAllPizzas() {
        List<PizzaResponse> pizzas = pizzaService.findAll();
        return ResponseEntity.ok(pizzas);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<PizzaResponse> getPizza(@PathVariable Long id) {
        return pizzaService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
    
    @PostMapping
    public ResponseEntity<PizzaResponse> createPizza(@Valid @RequestBody CreatePizzaRequest request) {
        PizzaResponse created = pizzaService.create(request);
        
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(created.id())
                .toUri();
        
        return ResponseEntity.created(location).body(created);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<PizzaResponse> updatePizza(
            @PathVariable Long id,
            @Valid @RequestBody UpdatePizzaRequest request) {
        
        return pizzaService.update(id, request)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletePizza(@PathVariable Long id) {
        if (pizzaService.delete(id)) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.notFound().build();
    }
}
```

### Step 6: Build and Test

```bash
# Clean and compile (MapStruct will generate mapper implementations)
mvn clean compile

# Check generated code
ls target/generated-sources/annotations/be/vives/pizzastore/mapper/

# Run the application
mvn spring-boot:run
```

### Step 7: Test with curl

```bash
# Create a pizza
curl -X POST http://localhost:8080/api/pizzas \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Margherita",
    "price": 8.50,
    "description": "Classic tomato and mozzarella"
  }'

# Response:
{
  "id": 1,
  "name": "Margherita",
  "price": 8.50,
  "description": "Classic tomato and mozzarella",
  "createdAt": "2024-11-05T10:30:00",
  "updatedAt": "2024-11-05T10:30:00"
}

# Get all pizzas
curl http://localhost:8080/api/pizzas

# Update a pizza
curl -X PUT http://localhost:8080/api/pizzas/1 \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Margherita Deluxe",
    "price": 9.50,
    "description": "Classic tomato and premium mozzarella"
  }'
```

---

## üß™ Testing with DTOs

### Test the Mapper

```java
package be.vives.pizzastore.mapper;

import be.vives.pizzastore.domain.Pizza;
import be.vives.pizzastore.dto.request.CreatePizzaRequest;
import be.vives.pizzastore.dto.response.PizzaResponse;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.math.BigDecimal;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
class PizzaMapperTest {
    
    @Autowired
    private PizzaMapper pizzaMapper;
    
    @Test
    void shouldMapEntityToResponse() {
        // Given
        Pizza pizza = new Pizza("Margherita", new BigDecimal("8.50"), "Classic");
        pizza.setId(1L);
        
        // When
        PizzaResponse response = pizzaMapper.toResponse(pizza);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.id()).isEqualTo(1L);
        assertThat(response.name()).isEqualTo("Margherita");
        assertThat(response.price()).isEqualByComparingTo("8.50");
        assertThat(response.description()).isEqualTo("Classic");
    }
    
    @Test
    void shouldMapCreateRequestToEntity() {
        // Given
        CreatePizzaRequest request = new CreatePizzaRequest(
            "Margherita",
            new BigDecimal("8.50"),
            "Classic"
        );
        
        // When
        Pizza pizza = pizzaMapper.toEntity(request);
        
        // Then
        assertThat(pizza).isNotNull();
        assertThat(pizza.getId()).isNull(); // Not set from request
        assertThat(pizza.getName()).isEqualTo("Margherita");
        assertThat(pizza.getPrice()).isEqualByComparingTo("8.50");
        assertThat(pizza.getDescription()).isEqualTo("Classic");
    }
}
```

### Test the Controller with DTOs

```java
package be.vives.pizzastore.controller;

import be.vives.pizzastore.dto.request.CreatePizzaRequest;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
class PizzaControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    void shouldCreatePizza() throws Exception {
        CreatePizzaRequest request = new CreatePizzaRequest(
            "Margherita",
            new BigDecimal("8.50"),
            "Classic"
        );
        
        mockMvc.perform(post("/api/pizzas")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").exists())
                .andExpect(jsonPath("$.name").value("Margherita"))
                .andExpect(jsonPath("$.price").value(8.50))
                .andExpect(jsonPath("$.createdAt").exists());
    }
    
    @Test
    void shouldRejectInvalidPizza() throws Exception {
        CreatePizzaRequest request = new CreatePizzaRequest(
            "", // Invalid: blank name
            new BigDecimal("-5.00"), // Invalid: negative price
            "Classic"
        );
        
        mockMvc.perform(post("/api/pizzas")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isBadRequest());
    }
}
```

---

## üí° Tips & Best Practices

### 1. **Use Records for DTOs** (Java 14+)

Records are perfect for DTOs:
- Immutable by default
- Concise syntax
- Built-in equals/hashCode/toString
- Named accessors (no get prefix)

```java
// Instead of this:
public class PizzaResponse {
    private final Long id;
    private final String name;
    // ... getters, equals, hashCode, toString
}

// Use this:
public record PizzaResponse(Long id, String name) {}
```

### 2. **Separate Request and Response DTOs**

Don't reuse DTOs for both input and output:

```java
// ‚ùå Bad: Same DTO for create and response
public record PizzaDTO(Long id, String name, BigDecimal price) {}

// ‚úÖ Good: Separate DTOs
public record CreatePizzaRequest(String name, BigDecimal price) {}
public record PizzaResponse(Long id, String name, BigDecimal price) {}
```

### 3. **Name DTOs Descriptively**

Be explicit about DTO purpose:

```java
// ‚ùå Bad naming
PizzaDTO.java

// ‚úÖ Good naming
CreatePizzaRequest.java
UpdatePizzaRequest.java
PizzaResponse.java
PizzaSummaryResponse.java  // For list views
PizzaDetailResponse.java   // For detailed views
```

### 4. **Keep DTOs Flat (When Possible)**

Avoid deep nesting in DTOs:

```java
// ‚ùå Avoid: Deep nesting
public record OrderResponse(
    Long id,
    CustomerResponse customer, // Full customer object
    List<OrderLineResponse> orderLines // Complex nested list
) {}

// ‚úÖ Better: Flat structure
public record OrderResponse(
    Long id,
    Long customerId,
    String customerName,
    int totalItems,
    BigDecimal totalAmount
) {}
```

### 5. **Use @JsonProperty for Different JSON Field Names**

```java
public record PizzaResponse(
    @JsonProperty("pizza_id")
    Long id,
    
    @JsonProperty("pizza_name")
    String name
) {}

// JSON output:
{
  "pizza_id": 1,
  "pizza_name": "Margherita"
}
```

### 6. **Null Handling in Mappers**

MapStruct handles nulls by default, but you can customize:

```java
@Mapper(
    componentModel = "spring",
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE
)
public interface PizzaMapper {
    // Null fields in source won't overwrite target
    void updateEntity(UpdatePizzaRequest request, @MappingTarget Pizza pizza);
}
```

### 7. **Different Response DTOs for Different Contexts**

```java
// For list views: minimal data
public record PizzaSummaryResponse(
    Long id,
    String name,
    BigDecimal price
) {}

// For detail views: complete data
public record PizzaDetailResponse(
    Long id,
    String name,
    BigDecimal price,
    String description,
    CategoryResponse category,
    List<String> ingredients,
    NutritionalInfo nutritionalInfo,
    LocalDateTime createdAt
) {}
```

---

## üéì Summary

### What We Learned

1. **Why DTOs Are Essential**
   - Never expose entities directly through REST APIs
   - Security: Prevent leaking sensitive data
   - Flexibility: Decouple API from database structure
   - Performance: Control what data is sent over the network

2. **Request vs Response DTOs**
   - **Request DTOs**: For creating/updating (no ID, validation)
   - **Response DTOs**: For returning data (includes ID, read-only)
   - Use different DTOs for different operations

3. **MapStruct for Mapping**
   - Compile-time code generation (type-safe and fast)
   - Better than manual mapping or ModelMapper
   - Spring integration with `componentModel = "spring"`
   - Easy to customize and debug

4. **Project Structure**
   - Separate packages: `domain`, `dto/request`, `dto/response`, `mapper`
   - Clear separation of concerns
   - Easy to navigate and maintain

5. **Benefits**
   - ‚úÖ Better security
   - ‚úÖ API stability
   - ‚úÖ Easier to evolve
   - ‚úÖ Better performance
   - ‚úÖ Easier testing
   - ‚úÖ Professional code structure

### Key Takeaways

‚ö†Ô∏è **NEVER expose entities directly**  
‚úÖ **ALWAYS use DTOs for API communication**  
üèÜ **Use MapStruct for mapping**  
üì¶ **Separate Request and Response DTOs**  
üéØ **Keep DTOs simple and focused**

---

## üìñ Additional Resources

- [MapStruct Documentation](https://mapstruct.org/)
- [MapStruct Spring Extensions](https://github.com/mapstruct/mapstruct-spring-extensions)
- [DTO Pattern Explained](https://martinfowler.com/eaaCatalog/dataTransferObject.html)
- [Java Records Documentation](https://docs.oracle.com/en/java/javase/17/language/records.html)
- [Spring Boot Validation](https://docs.spring.io/spring-boot/docs/current/reference/html/io.html#io.validation)

---

**Congratulations!** üéâ You now understand the importance of DTOs and know how to implement them with MapStruct. Your API is now more secure, maintainable, and professional!


---

## üöÄ Runnable Project

A complete, runnable Spring Boot project demonstrating all concepts from this lesson is available in:

**`pizzastore-with-dtos/`**

See the project README for:
- How to run the application
- API endpoints to test
- Database schema
- Complete working code


